/*
  ===============================================================================================================
  QMC5883PCompass.cpp   —  Three-axis magnetometer (QMC5883P) driver
  修订日期: 2025-07-31
  变更记录:
    • 将 getAzimuth() 的坐标系旋转 90° (Y→X, X→Y) 以匹配 PCB 丝印
    • 修正负角度归一化，返回值恒在 0-359°
  原始库作者:  MPrograms  ( https://github.com/mprograms/QMC5883LCompass )
  ===============================================================================================================
*/

#include "QMC5883PCompass.h"
#include <Arduino.h>
#include <Wire.h>

/* -------------------------------------------------------------------------------------------------------------
 *  构造函数
 * -----------------------------------------------------------------------------------------------------------*/
QMC5883PCompass::QMC5883PCompass() {}

/* -------------------------------------------------------------------------------------------------------------
 *  初始化（与原库一致，只改寄存器地址/数值以适配 QMC5883P）
 * -----------------------------------------------------------------------------------------------------------*/
void QMC5883PCompass::init() {
  Wire.begin();

  /* Reg 0x0B：量程 8 G (0x08) + SET/RESET 打开 (0x01) */
  _writeReg(0x0B, 0x08 | 0x01);

  /* Reg 0x0A：连续测量 (0x03) + ODR 200 Hz (0x0C) + OSR1 = 8 (0x00) */
  _writeReg(0x0A, 0x03 | 0x0C | 0x00);
}

/* -------------------------------------------------------------------------------------------------------------
 *  通用寄存器写
 * -----------------------------------------------------------------------------------------------------------*/
void QMC5883PCompass::_writeReg(byte reg, byte val) {
  Wire.beginTransmission(_ADDR);
  Wire.write(reg);
  Wire.write(val);
  Wire.endTransmission();
}

/* -------------------------------------------------------------------------------------------------------------
 *  模式设置（寄存器分布与 QMC5883L 不同）
 * -----------------------------------------------------------------------------------------------------------*/
void QMC5883PCompass::setMode(byte mode, byte odr, byte rng, byte osr) {
  byte regA = mode | odr | osr;
  byte regB = rng | 0x01;             // SET/RESET mode 置 1
  _writeReg(0x0B, regB);
  _writeReg(0x0A, regA);
}

/* -------------------------------------------------------------------------------------------------------------
 *  软复位
 * -----------------------------------------------------------------------------------------------------------*/
void QMC5883PCompass::setReset() { _writeReg(0x0B, 0x80); }

/* -------------------------------------------------------------------------------------------------------------
 *  读取原始 XYZ 轴
 * -----------------------------------------------------------------------------------------------------------*/
void QMC5883PCompass::read() {
  Wire.beginTransmission(_ADDR);
  Wire.write(0x01);                   // 起始地址 X_LSB
  if (!Wire.endTransmission()) {
    Wire.requestFrom(_ADDR, (byte)6);
    _vRaw[0] = (int16_t)(Wire.read() | Wire.read() << 8); // X
    _vRaw[1] = (int16_t)(Wire.read() | Wire.read() << 8); // Y
    _vRaw[2] = (int16_t)(Wire.read() | Wire.read() << 8); // Z

    _applyCalibration();
    if (_smoothUse) _smoothing();
  }
}

/* -------------------------------------------------------------------------------------------------------------
 *  获取单轴（若开启平滑则返回平滑值）
 * -----------------------------------------------------------------------------------------------------------*/
int QMC5883PCompass::_get(int idx) {
  return _smoothUse ? _vSmooth[idx] : _vCalibrated[idx];
}
int QMC5883PCompass::getX() { return _get(0); }
int QMC5883PCompass::getY() { return _get(1); }
int QMC5883PCompass::getZ() { return _get(2); }

/* -------------------------------------------------------------------------------------------------------------
 *  ★★ 计算方位角（已对应 PCB 坐标系：X→右=East=90°，Y→上=North=0°） ★★
 * -----------------------------------------------------------------------------------------------------------*/
int QMC5883PCompass::getAzimuth() {
  /* 传感器原生坐标:  Xraw→芯片 X, Yraw→芯片 Y
     PCB 丝印坐标:    Xpcb 在右, Ypcb 在上
     实测旋转 90° 即可吻合，所以用 Xraw 当 Ypcb、Yraw 当 Xpcb。
   */
  float heading = atan2(getX(), getY()) * 180.0f / PI;   // 旋转 90°
  heading += _magneticDeclinationDegrees;                // 地磁偏角补偿

  if (heading < 0.0f)  heading += 360.0f;
  if (heading >= 360.0f) heading -= 360.0f;
  return (int)heading;                                   // 0-359°
}

/* -------------------------------------------------------------------------------------------------------------
 *  其余：平滑 / 校准 / 获取 16 方位字母 —— 原库逻辑保持不变
 *  （以下代码完全拷贝自原版，仅格式化）
 * -----------------------------------------------------------------------------------------------------------*/

byte QMC5883PCompass::getBearing(int azimuth) {
  float a = (azimuth + 11.25f) / 22.5f;
  return (int)a % 16;
}
void QMC5883PCompass::getDirection(char *out, int azimuth) {
  int idx = getBearing(azimuth);
  out[0] = _bearings[idx][0];
  out[1] = _bearings[idx][1];
  out[2] = _bearings[idx][2];
}

/* --- 以下为校准、平滑等辅助函数 —— 无改动，若需查看可保留原文件内容 --- */

/* … (setSmoothing / calibrate / _applyCalibration / _smoothing 等函数原样放这里) … */
